/* Unchanging functions */
int configure ( int argc, char** argv )
{
    int opt;
    int idx = 0;
    
    /* GNU long option configuration */
    static struct option long_options[] =
    {
        { "input", required_argument, 0, 'i' },
        { "output", required_argument, 0, 'o' },
        { "detail", required_argument, 0, 'd' },
        { "NaN", no_argument, 0, 'N' },
        { "help", no_argument, 0, 'h' },
        { "symbols", no_argument, 0, 's' },
        { "model", no_argument, 0, 'm' },
        { "version", no_argument, 0, 'v' }
    };
    static char* short_options = "i:o:d:Nhsmv";
    
    /* process the command line options */
    appName = argv[0];
    
    while ( (opt = getopt_long(argc, argv, short_options, long_options, &idx)) != -1 )
    {
        switch (opt)
        {
            case 'i':
                inputName = optarg;
                break;
            
            case 'o':
                outputName = optarg;
                break;
            
            case 'd':
                detailName = optarg;
                break;
            
            case 'N':
                NAN_INIT = 1;
                break;
            
            case 'h':
                print_usage();
                return ERR_EXIT;
            
            case 's':
                DUMP_SYMBOLS = 1;
                break;
            
            case 'm':
                print_name();
                return ERR_EXIT;
            
            case 'v':
                print_version();
                return ERR_EXIT;
            
            /* bail for unknown options */
            default:
                return ERR_UNKNOWN_OPTION;
        }
    }
    
    if ( !DUMP_SYMBOLS && inputName )
    {
        inputFile = fopen(inputName, "r");
        if ( ! inputFile )
        {
            fprintf(stderr, "Error: unable to open file %s for reading\n", inputName );
            return ERR_BAD_FILE;
        }
    }
    else
    {
        inputFile = 0;
    }
    
    if ( !DUMP_SYMBOLS && outputName )
    {
        outputFile = fopen(outputName, "w");
        if ( !outputFile )
        {
            fprintf(stderr, "Error: unable to open file %s for writing\n", outputName );
            if ( inputFile )
                fclose(inputFile);
            return ERR_BAD_FILE;
        }
    }
    else
    {
        outputFile = stdout;
    }
    
    if ( !DUMP_SYMBOLS && detailName )
    {
        detailFile = fopen(detailName, "w");
        if ( !detailFile )
        {
            fprintf(stderr, "Error: unable to open file %s for writing\n", detailName );
            if ( inputFile )
                fclose(inputFile);
            if ( outputFile != stdout )
                fclose(outputFile);
            return ERR_BAD_FILE;
        }
    }
    
    return ERR_OK;
}

/* This will get more complicated eventually. */
void print_usage ()
{
    printf( "\nusage: %s [options]\n\n", appName );
    printf( " The following options take effect when running the model:\n" );
    printf( "  -i | --input FILE    specify input file (default none)\n" );
    printf( "  -o | --output FILE   specify output file (default stdout)\n" );
    printf( "  -d | --detail FILE   specify detailed output (default none)\n" );
    printf( "  -N | --NaN           initialise working data with NaNs\n\n" );
    printf( " If any of the following options are specified, the model is not run:\n" );
    printf( "  -h | --help          print this usage message\n" );
    printf( "  -s | --symbols       print the names of all model symbols\n" );
    printf( "  -m | --model         print the name of the model\n" );
    printf( "  -v | --version       print version information\n\n" );
}

void print_name ()
{
    /* may eventually want to wrap this up a bit more
       usefully, but for now... */
    printf("%s\n", MODEL_NAME);
}

void print_version ()
{
    printf( "%s model %s, generated by %s\n", MODEL_NAME, MODEL_VERSION, APP_VERSION );
}

void dump_symbols()
{
    /* print the symbol table -- the idea is that client
       code will be able to use this when generating
       input files (although I admit I'm a bit vague
       about this at present) */
    int ii;
    for ( ii = 0; ii < SYMBOL_COUNT; ++ii )
        printf("%s\t%g\n", SYMBOLS[ii], RPAR[ii]);
}

/* current input file spec is not fit for human consumption
   but instead designed for cheap and cheerless parsing
   a simple generator tool will be provided to smooth the way
   later on I'll improve this, since it's totally lame... */
int load_inputs()
{    
    const unsigned int MAX_LINE = 8192;
    char str[MAX_LINE];
    int* assignants = 0;
    int nSteps = -1;
    int stepIndex = 0;
    int nFields = -1;
    int ii;
    char* err;
    char* token;
    
    OutputSpec* currentOutSpec = &DEFAULT_OUTSPEC;
    OutputSpec* currentResultSpec = &DEFAULT_OUTSPEC;
    RadauOut currentOut = out;
    void (*currentResultFunc)(int, OutputSpec*, int) = result;
    int currentResultHeader = !0;
    int currentOutHeader = !0;
    
    /* with no input file, just run a default length single-step sim with no assignments */
    if ( ! inputFile )
    {
        STEPS = (Step*) calloc(1, sizeof(Step));
        STEP_COUNT = 1;
        STEPS[stepIndex].endx = DEFAULT_DURATION;
        STEPS[stepIndex].outHeader = currentOutHeader;
        STEPS[stepIndex].resultHeader = currentResultHeader;
        STEPS[stepIndex].out = currentOut;
        STEPS[stepIndex].resultFunction = currentResultFunc;
        STEPS[stepIndex].outSpec = currentOutSpec;
        STEPS[stepIndex].resultSpec = currentResultSpec;
        
        return 0;
    }
    
    /* first, read the total number of steps, so we can allocate them */
    while ( 1 )
    {
        err = fgets(str, MAX_LINE, inputFile);
        if ( err == NULL || feof(inputFile) || ferror(inputFile) )
            return ERR_INPUT_FAILED;
        
        if ( str[0] == '@' )
        {
            nSteps = atoi(str+1);
            if ( nSteps < 1 )
                return ERR_NO_STEPS;
            break;
        }
        
        if ( str[0] != '#' )
            return ERR_BAD_INPUT_LINE;
    }
    
    /* Allocate the step sequence (with calloc, so it's all inited to 0) */
    STEPS = (Step*) calloc(nSteps, sizeof(Step));
    STEP_COUNT = nSteps;
    
    /* next, read lines and construct steps */
    while ( stepIndex < STEP_COUNT )
    {
        err = fgets(str, MAX_LINE, inputFile);
        if ( err == NULL || feof(inputFile) || ferror(inputFile) )
        {
            /* step sequence is incomplete -- for the moment just bail
               although later we could attempt recovery... */
            return ERR_INCOMPLETE;
        }
        
        if ( str[0] == '#' )
            continue;
        
        if ( str[0] == ':' )
        {
            token = strtok(str, ": \t\n\r");
            nFields = atoi(token);
            
            if ( nFields < 0 )
                return ERR_BAD_NFIELDS;
            
            if (assignants)
                free(assignants);
            
            if ( nFields )
            {
                assignants = calloc(nFields, sizeof(int));
                if ( ! assignants )
                    return ERR_ALLOC;
            }
            else
            {
                assignants = 0;
            }
            
            for ( ii = 0; ii < nFields; ++ii )
            {
                token = strtok(NULL, ": \t\n\r");
                assignants[ii] = find_symbol(token);
            }           
        }
        else if ( str[0] == '=' )         /* absolute time step */
        {
            if ( nFields < 0 )
                return ERR_UNDEF_FIELDS;
            
            token = strtok(str, "= \t\n\r");
            if ( ! token )
                return ERR_TOKEN;
            STEPS[stepIndex].startx = atof(token);
            
            token = strtok(NULL, "= \t\n\r");
            if ( ! token )
                return ERR_TOKEN;
            STEPS[stepIndex].endx = atof(token);
            
            STEPS[stepIndex].param_count = nFields;
            STEPS[stepIndex].param_assigns = calloc(nFields, sizeof(Assign));
            if ( STEPS[stepIndex].param_assigns == NULL )
                return ERR_ALLOC;
            
            for ( ii = 0; ii < nFields; ++ii )
            {
                token = strtok(NULL, "= \t\n\r");
                if ( !token )
                    return ERR_TOKEN;
                
                STEPS[stepIndex].param_assigns[ii].index = assignants[ii];
                STEPS[stepIndex].param_assigns[ii].value = atof(token);
            }
            
            STEPS[stepIndex].outHeader = currentOutHeader;
            STEPS[stepIndex].resultHeader = currentResultHeader;
            STEPS[stepIndex].out = currentOut;
            STEPS[stepIndex].resultFunction = currentResultFunc;
            STEPS[stepIndex].outSpec = currentOutSpec;
            STEPS[stepIndex].resultSpec = currentResultSpec;

            currentOutHeader = 0;
            currentResultHeader = 0;
            
            ++stepIndex;
        }
        else if ( str[0] == '+' )         /* single relative time step with absolute parameters */
        {
            if ( nFields < 0 )
                return ERR_UNDEF_FIELDS;
            
            token = strtok(str, "+ \t\n\r");
            if ( ! token )
                return ERR_TOKEN;
            
            STEPS[stepIndex].startx = (stepIndex == 0) ? 0 : STEPS[stepIndex-1].endx;
            STEPS[stepIndex].endx = STEPS[stepIndex].startx + atof(token);
            
            STEPS[stepIndex].param_count = nFields;
            STEPS[stepIndex].param_assigns = calloc(nFields, sizeof(Assign));
            if ( STEPS[stepIndex].param_assigns == NULL )
                return ERR_ALLOC;
            
            for ( ii = 0; ii < nFields; ++ii )
            {
                token = strtok(NULL, "+ \t\n\r");
                if ( !token )
                    return ERR_TOKEN;
                
                STEPS[stepIndex].param_assigns[ii].index = assignants[ii];
                STEPS[stepIndex].param_assigns[ii].value = atof(token);
            }
   
            STEPS[stepIndex].outHeader = currentOutHeader;
            STEPS[stepIndex].resultHeader = currentResultHeader;
            STEPS[stepIndex].out = currentOut;
            STEPS[stepIndex].resultFunction = currentResultFunc;
            STEPS[stepIndex].outSpec = currentOutSpec;
            STEPS[stepIndex].resultSpec = currentResultSpec;

            currentOutHeader = 0;
            currentResultHeader = 0;
            
            ++stepIndex;
        }
        else if ( str[0] == '*' )         /* multiple relative time steps with relative parameters */
        {
            int reps;
            double interval;
            
            if ( nFields < 0 )
                return ERR_UNDEF_FIELDS;
            
            token = strtok(str, "* \t\n\r");
            if ( ! token )
                return ERR_TOKEN;
            
            reps = atoi(token);
            if ( reps < 1
                 || reps + stepIndex > STEP_COUNT )
                return ERR_BAD_REPS;
            
            token = strtok(NULL, "* \t\n\r");
            if ( ! token )
                return ERR_TOKEN;
            interval = atof(token);
            
            /* go through steps, allocating and setting start & end times */
            for ( ii = 0; ii < reps; ++ii )
            {
                STEPS[ii + stepIndex].startx = (ii + stepIndex <= 0) ? 0 : STEPS[ii + stepIndex - 1].endx;
                STEPS[ii + stepIndex].endx = STEPS[ii + stepIndex].startx + interval;
                     
                if ( nFields > 0 )
                {
                    STEPS[ii + stepIndex].param_count = nFields;
                    STEPS[ii + stepIndex].param_assigns = calloc(nFields, sizeof(Assign));
                    if ( STEPS[ii + stepIndex].param_assigns == NULL )
                        return ERR_ALLOC;
                }
                
                            
                STEPS[ii + stepIndex].outHeader = currentOutHeader;
                STEPS[ii + stepIndex].resultHeader = currentResultHeader;
                STEPS[ii + stepIndex].out = currentOut;
                STEPS[ii + stepIndex].resultFunction = currentResultFunc;
                STEPS[ii + stepIndex].outSpec = currentOutSpec;
                STEPS[ii + stepIndex].resultSpec = currentResultSpec;

                currentOutHeader = 0;
                currentResultHeader = 0;
            }
            
            /* set all assignments by appropriate incrementing */
            for ( ii = 0; ii < nFields; ++ii )
            {
                int jj;
                double value, increment;
                
                token = strtok(NULL, "* \t\n\r");
                if ( ! token )
                    return ERR_TOKEN;
                increment = atof(token);
                
                /* TODO: sort out the fact that this is unsafe if the fields have changed! */
                value = (stepIndex == 0) ? 0 : STEPS[stepIndex - 1].param_assigns[ii].value;
                
                for ( jj = 0; jj < reps; ++jj )
                {
                    /* semantics may be a bit iffy here for some cases, but since
                       we're starting from previous assignment we increment before */
                    value += increment;
                    STEPS[jj + stepIndex].param_assigns[ii].index = assignants[ii];
                    STEPS[jj + stepIndex].param_assigns[ii].value = value;
                }
            }
            
            stepIndex += reps;
        }
        else if ( str[0] == '!' )         /* output header(s) */
        {
            if ( str[1] == '!' )
            {
                currentOutHeader = 1;
                if ( str[2] == '!' )
                    currentResultHeader = 1;
            }
            else if ( str[1] == '0' )
            {
                currentOutHeader = currentResultHeader = 0;
            }
            else
            {
                currentResultHeader = 1;
            }
        }
        else if ( str[0] == '>' )         /* specify outputs */
        {
            int setOut = (str[1] == '>');
            int setResult = setOut ? (str[2] == '>') : 1;            

            token = strtok(str, "> \t\n\r");
            if ( ! token )
                return ERR_TOKEN;
            
            if ( token[0]=='*' )
            {   
                /* use the default output on one or both channels */
                if ( setResult )
                {
                    currentResultSpec = &DEFAULT_OUTSPEC;
                    currentResultFunc = result;
                }
                
                if ( setOut )
                {
                    currentOutSpec = &DEFAULT_OUTSPEC;
                    currentOut = out;
                }
            }
            else
            {
                int outCount = atoi(token);
                
                if ( outCount < 1 )
                {
                    /* no output on one or both output channels */
                    
                    if ( setResult )
                    {
                        currentResultSpec = 0;
                        currentResultFunc = 0;
                    }
                    
                    if ( setOut )
                    {
                        currentOut = out_none;
                        currentOutSpec = 0;
                    }
                }
                else
                {
                    /* create a new output spec and assign it */
                    OutputSpec* spec = create_output_spec(outCount);
                                        
                    if ( ! spec )
                    {
                        return ERR_OUTSPEC_FAILURE;
                    }
                    
                    if ( setResult )
                    {
                        currentResultFunc = result;
                        currentResultSpec = spec;
                    }
                    
                    if ( setOut )
                    {
                        currentOut = out;
                        currentOutSpec = spec;
                    }
                }
            }
        }
    }
    
    fclose(inputFile);
    
    return 0;
}

/* Create a new OutputSpec for the output functions, dealing with block allocation
   as necessary. This assumes that a string tokenization using strtok() is already 
   n progress, and pulls field names from it. That should be valid when called from
   load_inputs() -- there are probably no other circumstances in which this function
   should be called...
   
   Returns a pointer to the created OutputSpec, or NULL if there was an allocation
   failure or malformed specification. */
OutputSpec* create_output_spec(int outCount)
{
    int ii;
    
    /* (Re)-allocate a block of specs if necessary. */
    if ( 0 == (nextSpec % SPEC_ALLOC_SIZE ) )
    {
        OutputSpec* block = calloc(nextSpec + SPEC_ALLOC_SIZE, sizeof(OutputSpec));
        if ( !block )
            return 0;
        
        if ( nextSpec )
        {
            /* Copy previous specs to the new bigger block. This is
               inefficient, but we don't expect to be hitting it often. */
            for ( ii = 0; ii < nextSpec; ++ii )
            {
                block[ii].count = customSpecs[ii].count;
                block[ii].fields = customSpecs[ii].fields;
            }
            
            free(customSpecs);
        }
        
        customSpecs = block;
    }
    
    customSpecs[nextSpec].fields = calloc(outCount, sizeof(int));
    if ( ! customSpecs[nextSpec].fields )
        return 0;
    
    customSpecs[nextSpec].count = outCount;
    
    for ( ii = 0; ii < outCount; ++ii )
    {
        char* token = strtok(NULL, "> \t\n\r");
        customSpecs[nextSpec].fields[ii] = find_symbol(token);
    }
    
    /* textbook use case for postincrement operator! */
    return customSpecs + nextSpec++;
}

/* Lookup a symbol in the symbol table
   - this is an inefficient search, but in general we shouldn't
   be using it much. */
int find_symbol ( const char* symbol )
{
    int ii;
    
    /* we might get NULL out of strtok, which we count as an unknown symbol */
    if ( symbol )
    {
        for ( ii = 0; ii < SYMBOL_COUNT; ++ii )
        {
            if ( strcmp(symbol, SYMBOLS[ii]) == 0 )
            {
                return(ii);
            }
        }
    }
    
    /* NB: this is an unknown param index, not an error code! */
    return (-1);
}

/* Returns 0 if all's well, otherwise call finish() and exit */
int initialise()
{
    int err;
    
    if ( (err = radau5_alloc( DIFF_EQ_COUNT,
                             ALGEBRAIC_COUNT,
                             DIAGONAL,
                             REQUIRE_MASS,
                             SYMBOL_COUNT,
                             IPAR_COUNT )) )
        return err;
    
    RPAR = radau5_getDoubleParams();
    IPAR = radau5_getIntParams();
    Y = radau5_getY();

    if ( NAN_INIT )
    {
#ifdef NAN
        int ii;
        for ( ii = 0; ii < SYMBOL_COUNT; ++ii )
            RPAR[ii] = NAN;
#else
        return ERR_NAN_UNDEFINED;
#endif
    }

    /* if this works, it will assign STEPS & STEP_COUNT */
    if ( (err = load_inputs()) )
        return err;
    
    /* do any static initialisation specified for the model */
    model_init();
    
    return 0;
}

/* Output of the model state during evaluation */
void out(int* nr, double* xold, double* x, double* y, double* cont,
         int* lrc, int* n, double* rpar, int* ipar, int* irtrn)
{
    if ( SAVE_Y )
    {
        save_y(y);
        RPAR[0] = *x;
    }
    
    if ( RECALC_INTERMEDIATES )
    {
        rhs(0, x, y, 0, rpar, ipar);
        if ( SAVE_RECALCED )
            save_intermediates();
    }
    
    if ( detailFile && outSpec )
    {
        int ii;
        fprintf(detailFile, "%d", *nr);
        for ( ii = 0; ii < outSpec->count; ++ii )
        {
            if ( outSpec->fields[ii] >= 0 )
                fprintf(detailFile, "\t%.17g", RPAR[outSpec->fields[ii]]);
        }
        fprintf(detailFile, "\n");
    }
}

/* Dummy output function that doesn't output anything. */
void out_none(int* nr, double* xold, double* x, double* y, double* cont,
              int* lrc, int* n, double* rpar, int* ipar, int* irtrn)
{
    if ( SAVE_Y )
    {
        save_y(y);
        RPAR[0] = *x;
    }

    if ( RECALC_INTERMEDIATES )
    {
        rhs(0, x, y, 0, rpar, ipar);
        if ( SAVE_RECALCED )
            save_intermediates();
    }
}

void out_header()
{
    /* print a header for tab-delim detail output */
    if ( detailFile && outSpec )
    {
        int ii;
        fprintf(detailFile, "STEP");
        for ( ii = 0; ii < outSpec->count; ++ii )
        {
            if ( outSpec->fields[ii] >= 0 )
                fprintf(detailFile, "\t%s", SYMBOLS[outSpec->fields[ii]]);
        }
        fprintf(detailFile, "\n");
    }
}

void result_header(OutputSpec* spec)
{
    int ii;
    fprintf(outputFile, "ERR");
    for ( ii = 0; ii < spec->count; ++ii )
    {
        if ( spec->fields[ii] >= 0 )
            fprintf(outputFile, "\t%s", SYMBOLS[spec->fields[ii]]);
    }
    fprintf(outputFile, "\n");
}

/* Output of the model state at the completion of a sequence step
   -- at present this is extremely simplistic, just printing results
   in a tab-delimited text table format */
void result(int err, OutputSpec* spec, int header)
{
    if ( spec )
    {
        int ii;
    
        if ( header )
            result_header(spec);
    
        fprintf(outputFile, "%d", err);
        for ( ii = 0; ii < spec->count; ++ii )
        {
            if ( spec->fields[ii] >= 0 )
                fprintf(outputFile, "\t%.17g", RPAR[spec->fields[ii]]);
        }
        fprintf(outputFile, "\n");
    }
}

int run()
{
    int ii;
    int radau_err = 0;
    
    for ( ii = 0; ii < STEP_COUNT; ++ii )
    {
        int jj;
        
        for ( jj = 0; jj < STEPS[ii].param_count; ++jj )
            if ( STEPS[ii].param_assigns[jj].index >= 0 )
                RPAR[STEPS[ii].param_assigns[jj].index] = STEPS[ii].param_assigns[jj].value;
        
        outSpec = STEPS[ii].outSpec;
        if ( STEPS[ii].outHeader )
            out_header();
        
        if ( CARRY & CARRY_BEFORE )
            carry_forward();
        
        /* propagate changes to any dependent parameters */
        param_update();
        
        /* special case: assign params only, don't actually run */
        if ( STEPS[ii].startx == 0 && STEPS[ii].endx == 0 )
            continue;
        
        if ( CARRY & CARRY_BETWEEN )
            carry_forward();
        
        radau_err = radau5_solve ( STEPS[ii].startx, STEPS[ii].endx, NULL, rhs, STEPS[ii].out );
        
        if ( STEPS[ii].resultFunction )
            STEPS[ii].resultFunction(radau_err, STEPS[ii].resultSpec, STEPS[ii].resultHeader);
        
        /* TODO: offer a bailout route */
        
        if ( CARRY & CARRY_AFTER )
            carry_forward();
    }
    
    return radau_err;
}

void finish()
{
    /* deallocate steps */
    int ii;
    for ( ii = 0; ii < STEP_COUNT; ++ii )
    {
        free(STEPS[ii].param_assigns);
        STEPS[ii].param_assigns = 0;
    }
    
    free(STEPS);
    STEPS = 0;
    
    /* close files */
    if ( outputFile && outputFile != stdout )
    {
        fclose(outputFile);
        outputFile = 0;
    }
    
    if ( detailFile )
    {
        fclose(detailFile);
        detailFile = 0;
    }
    
    /* deallocate the radau5 stuff */
    radau5_dealloc();
    
    /* deallocate any OutputSpecs that have been created */
    for ( ii = 0; ii < nextSpec; ++ii )
        free(customSpecs[ii].fields);
    free(customSpecs);
    
    /* various pointers are dangling at this point, but we're
       only going to exit. Hopefully. */
}

/* Main entry point */
int main ( int argc, char** argv )
{
    int err;
    
    if ( (err = configure(argc, argv)) )
    {
        finish();
        fprintf(stderr, "%s\n", ERROR_MESSAGES[err]);
        return err;
    }
    
    if ( (err = initialise()) )
    {
        finish();
        fprintf(stderr, "%s\n", ERROR_MESSAGES[err]);
        return err;
    }
    
    if ( DUMP_SYMBOLS )
    {
        dump_symbols();
        finish();
        return 0;
    }
    
    err = ERR_RADAU_OFFSET + run();
    fprintf(stderr, "%s\n", ERROR_MESSAGES[err]);
    finish();
    return ( err == ERR_RADAU_OK ) ? 0 : err;
}

