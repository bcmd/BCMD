# export model as a single consolidated modeldef
# although this is not exactly a documentation format,
# the process is similar enough structurally to group with those modules
import sys
import os
import os.path
import re
import datetime, time
import decimal

def writeDoc(model, config):
    with open(os.path.join(config['outdir'], config['modeldef']), 'w') as f:
        printHeader(f, model, config)
        printModelDocs(f, model, config)
        printDirectives(f, model, config)
        printEmbeds(f, model, config)
        printReactions(f, model, config)
        printDiffs(f, model, config)
        printAlgs(f, model, config)
        printRoots(f, model, config)
        printIntermeds(f, model, config)
        printParameters(f, model, config)
        printFooter(f, model, config)
        
def printHeader(file, model, config):
    print >> file, '# consolidated modeldef for model %s' % config['name']
    print >> file, '# generated by BCMD module doc_modeldef.py'
    print >> file, '# %s' % datetime.datetime.fromtimestamp(time.time()).strftime('%Y-%m-%d %H:%M:%S')
    print >> file, ''

def printFooter(file, model, config):
    pass

def printDirectives(file, model, config):
    some = False

    # TODO: break each of the following into multiple directives if there are many    
    if model['inputs']:
        print >> file, '@input %s' % ' '.join(model['inputs'])
        some = True
        
    if model['outputs'] and (set(model['outputs']) != set(model['roots'])):
        print >> file, '@output %s' % ' '.join(model['outputs'])
        some = True

    if model['extern']:
        print >> file, '@extern %s' % ' '.join(model['extern'])
        some = True
    
    if some:
        print >> file, ''

    
def printEmbeds(file, model, config):
    if model['embeds']:
        print >> file, '# embedded C code'
        print >> file, '[**'
        for embed in model['embeds']:
            print >> file, embed
        print >> file, '**]'
        print >> file, ''

def printModelDocs(file, model, config):
    some = False
    for line in model['modeldocs']:
        if not (line.startswith('@') or line.startswith('$') or line.startswith('~')):
             print >> file, '## %s' % line
             some = True
    if some:
        print >> file, '## @\n'

def printReactions(file, model, config):
    if not model['reactions']:
        return
    
    print >> file, '# chemical reactions'
    
    for reac in sorted(model['reactions'].keys(), key=lambda s: s.lower()):
        # merge forward/reverse pairs into single two-way reactions
        if reac.endswith('_reverse') and (reac[:-7] + 'forward') in model['reactions']:
            continue
        
        op = '->'
        
        # collect terms and forward rate
        lhs = ''
        for term in model['reactions'][reac]['lhs']:
            stoich = translate(term['mathterm_unmod'], model, config)[0]           
            try:
                dec = decimal.Decimal(stoich)
                if dec == 1:
                    stoich = ''
            except:
                pass
            
            if stoich:
                stoich = stoich + ' '
            
            chem = term['chem']
            if lhs:
                lhs = '%s + %s[%s]' % (lhs, stoich, chem)
            else:
                lhs = '%s[%s]' % (stoich, chem)
            
        
        rhs = ''
        for term in model['reactions'][reac]['rhs']:
            stoich = translate(term['mathterm_unmod'], model, config)[0]
            try:
                dec = decimal.Decimal(stoich)
                if dec == 1:
                    stoich = ''
            except:
                pass
            
            if stoich:
                stoich = stoich + ' '
            
            chem = term['chem']
            if rhs:
                rhs = '%s + %s[%s]' % (rhs, stoich, chem)
            else:
                rhs = '%s[%s]' % (stoich, chem)
        
        fspec = model['reactions'][reac]['ratespec']
        fargs = ','.join([translate(x[1], model, config)[0] for x in fspec[2][1:]])
        if fspec[1] == 'MA':
            forward = '{MA:%s}' % fargs
        elif fspec[1] == 'MM':
            forward = '{MM:%s}' % fargs
        else:
            forward = '{%s}' % fargs
        
        # if there's a reverse reaction, get that rate too
        if reac.endswith('_forward') and (reac[:-7] + 'reverse') in model['reactions']:
            rspec = model['reactions'][reac[:-7] + 'reverse']['ratespec']
            rargs = ','.join([translate(x[1], model, config)[0] for x in rspec[2][1:]])
            if rspec[1] == 'MA':
                reverse = '{MA:%s}' % rargs
            elif rspec[1] == 'MM':
                reverse = '{MM:%s}' % rargs
            else:
                reverse = '{%s}' % rargs           
            op = '<->'
        else:
            reverse = ''
            rspec = ()
        
        print >> file, ('%s %s %s %s %s' % (lhs, op, rhs, forward, reverse)).strip()
        
    print >> file, ''

## TEMP HACK -- ultimately I expect to just get rid of this entirely...
def latexName(name, model, insert=True):
    return name

def printDiffs(file, model, config):
    if not model['diffs']:
        return
    
    print >> file, '# differential equations'
    if config.get('model-comment-chem-diffs', True) and any([x in model['chemicals'] for x in model['diffs']]):
        print >> file, '#   note: commented out equations are defined by the chemical reactions above'
        print >> file, '#         translated forms are shown here for information only'
    
    tt = latexName(model['symlist'][0], model)
    first = True
    
    for name in sorted(model['diffs'], key=lambda s: s.lower()):
        lhs = "%s'" % latexName(name, model)
        for aux in model['auxiliaries'][name]:
            mass = aux[0]
            if mass < 0:
                mass = -mass
                op = '-'
            else:
                op = '+'
            if mass == 1:
                mstr = ''
            else:
                mstr = str(mass)
            lhs = lhs + op + mstr + "%s'" % latexName(aux[1], model)
        
        rhs = substitute(model['symbols'][name]['diffs'][0], model, config).strip()
        
        if name in model['chemicals']:
            if config.get('model-comment-chem-diffs', False):
                print >> file, '# %s = %s' % (lhs, rhs)
        else:
            print >> file, '%s = %s' % (lhs, rhs)

    print >> file, ''

def printAlgs(file, model, config):
    if not model['algs']:
        return
    
    print >> file, '# algebraic relations'
    
    for name in sorted(model['algs'], key=lambda s: s.lower()):
        rhs = substitute(model['symbols'][name]['algs'][0], model, config)
        
        print >> file, '%s : 0 = %s' % (name, rhs)

    print >> file, ''


def printRoots(file, model, config):
    printVars(sorted(model['roots'], key=lambda s: s.lower()), 'state variables', file, model, config, omit_expr=True)

def printIntermeds(file, model, config):
    printVars(sorted(model['intermeds'], key=lambda s: s.lower()), 'intermediate variables', file, model, config)

def printParameters(file, model, config):
    printVars(sorted(model['params'], key=lambda s: s.lower()), 'parameters', file, model, config)

def printVars(vars, title, file, model, config, omit_expr=False):
    if vars:
        print >> file, '# %s' % title
        print >> file, ''
            
        for name in vars:
            printVar(name, file, model, config, omit_expr)

        print >> file, ''

def printVar(name, file, model, config, omit_expr=False):
    sym = model['symbols'][name]
    
    for line in sym['docs']:
        if line.startswith('+') or line.startswith('@') or line.startswith('$') or line.startswith('~'):
            pass
        else:
            print >> file, '## %s' % line
    
    units = sym.get('units', '')
    if units:
        print >> file, '## ~ %s' % units
    
    latex = sym.get('latex', '')
    if latex:
        print >> file, '## $%s$' % latex
    
    tags = ' '.join(sym.get('tags', []))
    if tags:
        print >> file, '## + %s' % tags

    noninits = []
    if not omit_expr:
        noninits = [x for x in sym['assigns'] if not x['init']]
        if noninits:
            noninit = substitute(noninits[0], model, config)
            print >> file, '%s = %s' % (name, noninit)

    inits = [x for x in sym['assigns'] if x['init']]
    if inits:
        init = substitute(inits[0], model, config)
    elif noninits:
        # skip the default initialiser if there is already an assignment
        init = None
    else:
        init = '0'
    
    if init is not None:
        print >> file, '%s := %s' % (name, init)
    
    for constraint in sym['constraints']:
        # at present the compiler doesn't store a mathexpr for constraints, so use the old expr stuff
        # (this will also need to be extended if and when soft constraints ever get implemented)
        invtest = { '>':'<=', '>=':'<', '<':'>=', '<=':'>'}.get(constraint['test'], 'ERROR')
        if not (name in model['chemicals'] and (invtest == '>=') and constraint['expr']=='0'):
            print >> file, '%s %s %s' % ( name, invtest, constraint['expr'] )
    
    print >> file, ''

def substitute(init, model, config):
    # init is an assigns entry, ie a dict with expr, depends, etc
    # we don't yet construct mathterms for diff eqs from chem eqs, so have to check
    if 'mathterm' in init:
        expr = translate(init['mathterm'], model, config)[0]
    else:
        expr = init['expr']

        # need to have some way of managing collisions here -- this will eventually get more sensible
        # but for now, we substitute long ids before short
        for dep in sorted(init['depends'], key=lambda x:-len(x)):
            expr = expr.replace(dep, latexName(dep, model))
    
    return expr

def translate(math, model, config):
    if isinstance(math, decimal.Decimal):
        # yet another formatting special case, purely because these annoy me!
        result = str(math)
        if result.endswith('.0'):
            result = result[:-2]
        return (result, '')
    if isinstance(math, str):
        return (latexName(math, model), '')
    if math[0] == 'function':
        if len(math) < 3:
            args = ''
        else:
            args = ', '.join([ translate(x[1], model, config)[0] for x in math[2][1:] ])
        return ('%s(%s)' % (math[1], args), '')
    if math[0] == 'conditional':
        return ('%s ? %s : %s' % (translate_binop(math[1], model, config)[0],
                                  translate(math[2][1], model, config)[0],
                                  translate(math[3][1], model, config)[0]), '')
    if math[0] == 'arithmetic':
        return translate_binop(math, model, config)
    
    return ('[ERROR]', '')

def translate_binop(math, model, config):
    lhs, lop = translate(math[2][1], model, config)
    rhs, rop = translate(math[3][1], model, config)
    
    # check for pure numbers, because we want to handle some special cases
    try:
        L = decimal.Decimal(lhs)
    except:
        L = None
    
    try:
        R = decimal.Decimal(rhs)
    except:
        R = None
        
    if math[1] == '*':
        if lop == '+' or lop == '-':
            lhs = '(%s)' % lhs
        if rop == '+' or rop == '-':
            rhs = '(%s)' % rhs

        # numeric special cases     
        if L is not None:
            # nested special case for our stupid handling of unary minus in the parser...
            if L == -1:
                op = ''
                lhs = ''
                rhs = '-%s' % rhs
            # and to eliminate superfluous multiplications by 1
            elif L == 1:
                op = ''
                lhs = ''
            else:
                op = '*'
        elif R is not None:
            if R == 1:
                op = ''
                rhs = ''
            else:
                op = '*'
        else:
            op = '*'
        return (('%s %s %s' % (lhs, op, rhs)).strip(), '*')
    
    if math[1] == '/':
        if lop == '+' or lop == '-':
            lhs = '(%s)' % lhs
        if rop == '+' or rop == '-' or rop == '*' or rop == '/':
            rhs = '(%s)' % rhs
        return ('%s / %s' % (lhs, rhs), '/')
    
    if math[1] == '^':
        if lop != '':
            lhs = '(%s)' % lhs
        return ('%s^(%s)' % (lhs, rhs), '^')
        
    if math[1] == '+':
        # another dodgy special case: convert + - into -
        if rhs.strip().startswith('-'):
            return( '%s - %s' % (lhs, rhs.strip()[1:]), '-' )
        # and yet another, perhaps dodgiest of all: convert -a + b into b - a
        if lhs.strip().startswith('-'):
            return( '%s - %s' % (rhs, lhs.strip()[1:]), '-' )
        return ('%s + %s' % (lhs, rhs), '+')
        
    if math[1] == '-':
        if rop == '-':
            rhs = '(%s)' % rhs
        return ('%s - %s' % (lhs, rhs), '-')
    
    # all remaining binops are logical
    # these only occur in conditions and have the weakest precedence, so we never bracket
    return ('%s %s %s' %(lhs, math[1], rhs), '')
